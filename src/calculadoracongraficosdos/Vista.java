/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package calculadoracongraficosdos;

import java.awt.Cursor;
import java.util.ArrayList;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.plaf.OptionPaneUI;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;

/**
 *
 * @author alang
 */
public class Vista extends javax.swing.JFrame {
    
     ImageIcon Calcu = new ImageIcon(getClass().getResource("/imagenes/calcu.png"));
    
    Validar v = new Validar();
        //arreglo de redes
        int ArrayClasesRed [][] = {{2,4,8,16,32,64,128,256},
                            {512,1024,2048,4096,8192,16384,32768,65536},
                            {131072,262144,524288,1048576,2097152,4194304,8388608,16777216}};
        
        String red,primeraip,ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR;
        int numRedes=0,totalHost=0,arregloRed=0,cond=0,cond2=0,x=0,cond3=0,suma=0,diagonalredC=24,diagonalredB=16,diagonalredA=8,sumados=0,cond4=0,RedNum,ContadorDenumeros=0,NumHostRed=0,ContadorParaIf=0,TotalDeRedes=0;
        int a=0,b=0,c=0;
      
       
         
    ArrayList <Redes> Lista = new ArrayList <Redes>();
    
    public Vista() {
     //   this.setUndecorated(rootPaneCheckingEnabled);
        initComponents();
        iniConfiguraciones();
        v.LimitarCaracteres(TxtOctetoUno, 3);
        v.LimitarCaracteres(TxtOctetoDos, 3);
        v.LimitarCaracteres(TxtOctetoTres, 3);
        v.LimitarCaracteres(TxtOctetoCuatro, 3);
        
        v.ValidarNumeros(TxtHost);
        v.ValidarNumeros(TxtRedes);
         v.ValidarNumeros(TxtOctetoUno);
          v.ValidarNumeros(TxtOctetoDos);
           v.ValidarNumeros(TxtOctetoTres);
            v.ValidarNumeros(TxtOctetoCuatro);
    }
    
      

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        TxtRedes = new javax.swing.JTextField();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        TxtOctetoUno = new javax.swing.JTextField();
        TxtHost = new javax.swing.JTextField();
        TxtOctetoDos = new javax.swing.JTextField();
        TxtOctetoTres = new javax.swing.JTextField();
        TxtOctetoCuatro = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        LblTipoRed = new javax.swing.JLabel();
        LblMascara = new javax.swing.JLabel();
        LblPrefijo = new javax.swing.JLabel();
        BtnEstatico = new javax.swing.JButton();
        BtnDinamico = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        TablaRedes = new javax.swing.JTable();
        LblHostDisponibles = new javax.swing.JLabel();
        BtnReset = new javax.swing.JButton();
        LblInformacion = new javax.swing.JLabel();
        LblSalir = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();

        TxtRedes.setText("0");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(null);

        jPanel1.setBackground(new java.awt.Color(51, 51, 51));
        jPanel1.setForeground(new java.awt.Color(102, 102, 102));

        jLabel1.setFont(new java.awt.Font("Arial", 1, 18)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("Direccion IP");

        jLabel3.setFont(new java.awt.Font("Arial", 1, 36)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(255, 255, 255));
        jLabel3.setText("Redes");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(37, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel3)
                    .addComponent(jLabel1))
                .addGap(34, 34, 34))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(47, 47, 47)
                .addComponent(jLabel1)
                .addGap(72, 72, 72)
                .addComponent(jLabel3)
                .addContainerGap(60, Short.MAX_VALUE))
        );

        getContentPane().add(jPanel1);
        jPanel1.setBounds(16, 34, 178, 244);

        jPanel2.setBackground(new java.awt.Color(51, 51, 51));
        jPanel2.setForeground(new java.awt.Color(102, 102, 102));

        TxtOctetoUno.setText("0");
        TxtOctetoUno.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TxtOctetoUnoActionPerformed(evt);
            }
        });

        TxtHost.setFont(new java.awt.Font("Arial", 1, 48)); // NOI18N
        TxtHost.setText("000");

        TxtOctetoDos.setText("0");

        TxtOctetoTres.setText("0");

        TxtOctetoCuatro.setText("0");

        jLabel2.setText(".");

        jLabel4.setFont(new java.awt.Font("Arial", 1, 18)); // NOI18N
        jLabel4.setText(".");

        jLabel5.setFont(new java.awt.Font("Arial", 1, 18)); // NOI18N
        jLabel5.setText(".");

        jLabel6.setFont(new java.awt.Font("Arial", 1, 18)); // NOI18N
        jLabel6.setText(".");

        LblTipoRed.setFont(new java.awt.Font("Arial Black", 1, 12)); // NOI18N
        LblTipoRed.setForeground(new java.awt.Color(255, 255, 255));

        LblMascara.setBackground(new java.awt.Color(255, 255, 255));
        LblMascara.setForeground(new java.awt.Color(255, 255, 255));

        LblPrefijo.setForeground(new java.awt.Color(255, 255, 255));

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(TxtHost, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanel2Layout.createSequentialGroup()
                                        .addComponent(LblMascara, javax.swing.GroupLayout.PREFERRED_SIZE, 233, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(0, 0, Short.MAX_VALUE))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                                        .addGap(0, 0, Short.MAX_VALUE)
                                        .addComponent(LblTipoRed, javax.swing.GroupLayout.PREFERRED_SIZE, 233, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel2)
                                .addContainerGap(43, Short.MAX_VALUE))
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(LblPrefijo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addContainerGap())))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(TxtOctetoUno, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(8, 8, 8)
                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(TxtOctetoDos, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(TxtOctetoTres, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(9, 9, 9)
                        .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 8, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(TxtOctetoCuatro, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TxtOctetoUno, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(TxtOctetoDos, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(TxtOctetoTres, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(TxtOctetoCuatro, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6))
                .addGap(47, 47, 47)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(TxtHost, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(LblTipoRed, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 20, Short.MAX_VALUE)
                                .addComponent(LblMascara, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(18, 18, 18)
                        .addComponent(LblPrefijo, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(13, 13, 13))))
        );

        getContentPane().add(jPanel2);
        jPanel2.setBounds(220, 34, 430, 244);

        BtnEstatico.setBackground(new java.awt.Color(102, 102, 102));
        BtnEstatico.setForeground(new java.awt.Color(255, 255, 255));
        BtnEstatico.setText("ESTATICO");
        BtnEstatico.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BtnEstaticoActionPerformed(evt);
            }
        });
        getContentPane().add(BtnEstatico);
        BtnEstatico.setBounds(660, 40, 162, 105);

        BtnDinamico.setBackground(new java.awt.Color(102, 102, 102));
        BtnDinamico.setForeground(new java.awt.Color(255, 255, 255));
        BtnDinamico.setText("DINAMICO");
        BtnDinamico.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BtnDinamicoActionPerformed(evt);
            }
        });
        getContentPane().add(BtnDinamico);
        BtnDinamico.setBounds(660, 160, 162, 112);

        TablaRedes.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "#Red", "Subred", "Primera IP", "Ultima IP", "Broadcast", "MascaraRed", " /...", "Host x Red"
            }
        ));
        jScrollPane1.setViewportView(TablaRedes);

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(10, 310, 960, 220);
        getContentPane().add(LblHostDisponibles);
        LblHostDisponibles.setBounds(175, 290, 0, 0);

        BtnReset.setBackground(new java.awt.Color(102, 102, 102));
        BtnReset.setForeground(new java.awt.Color(255, 255, 255));
        BtnReset.setText("RESET");
        BtnReset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BtnResetActionPerformed(evt);
            }
        });
        getContentPane().add(BtnReset);
        BtnReset.setBounds(830, 90, 130, 140);

        LblInformacion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/0.png"))); // NOI18N
        LblInformacion.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                LblInformacionMouseClicked(evt);
            }
        });
        getContentPane().add(LblInformacion);
        LblInformacion.setBounds(880, 10, 40, 40);

        LblSalir.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/00.png"))); // NOI18N
        LblSalir.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                LblSalirMouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                LblSalirMouseEntered(evt);
            }
        });
        getContentPane().add(LblSalir);
        LblSalir.setBounds(930, 10, 40, 40);

        jLabel7.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/12.png"))); // NOI18N
        getContentPane().add(jLabel7);
        jLabel7.setBounds(0, 0, 1000, 580);
        getContentPane().add(jScrollPane2);
        jScrollPane2.setBounds(70, 303, 140, 30);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void BtnEstaticoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BtnEstaticoActionPerformed
      
   //     String Direccion = TxtOctetoUno.getText()+"."+TxtOctetoDos.getText()+"."+TxtOctetoTres.getText()+"."+TxtOctetoCuatro.getText();
        
          if (TxtOctetoUno.getText().isEmpty()) {
            TxtOctetoUno.setText("0");
        }
        
        int ValidaRed = Integer.parseInt(TxtOctetoUno.getText());
        
      
        
        if (ValidaRed<128) { //Clase A
              reiniciarVariables();
             reiniciarJTable(TablaRedes);
            LblTipoRed.setText("Red Clase : A");
            LblMascara.setText("MASCARA DE RED: 255.0.0.0");
            LblPrefijo.setText("PREFIJO INIICAL:  /8");
            System.out.println("Clase A");
           
            calcularRedesClaseA(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
             mostrarSubneteo();
        }else if (ValidaRed<192) {//Clase B
              reiniciarVariables();
             reiniciarJTable(TablaRedes);
            LblTipoRed.setText("Red Clase : B");
            LblMascara.setText("MASCARA DE RED: 255.255.0.0");
            LblPrefijo.setText("PREFIJO INIICAL:  /16");
            System.out.println("Clase B");
            calcularRedesClaseB(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
             mostrarSubneteo();
        }else if (ValidaRed<224) {//Clase C
             reiniciarVariables();
            reiniciarJTable(TablaRedes);
          LblTipoRed.setText("Red Clase : C");
          LblMascara.setText("MASCARA DE RED: 255.255.255.0");
          LblPrefijo.setText("PREFIJO INIICAL:  /24");
         calcularRedesClaseC(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
         mostrarSubneteo();
      
        }else{ //Fuera de rango
            JOptionPane.showMessageDialog(null, "FUERA DE RANGO","RED NO SE PUEDE SUBNETEAR",JOptionPane.WARNING_MESSAGE);
        }
     
        
     
            
    }//GEN-LAST:event_BtnEstaticoActionPerformed

    private void BtnDinamicoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BtnDinamicoActionPerformed
     
              int ValidaRed = Integer.parseInt(TxtOctetoUno.getText());
        
        if (ValidaRed<128) { //Clase A
            reiniciarVariables();
             reiniciarJTable(TablaRedes);
            LblTipoRed.setText("Red Clase : A");
            LblMascara.setText("MASCARA DE RED: 255.0.0.0");
            LblPrefijo.setText("PREFIJO INIICAL:  /8");
            System.out.println("Clase A");
            
            calcularRedesClaseADinamico(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
             mostrarSubneteo();
        }else if (ValidaRed<192) {//Clase B
              reiniciarVariables();
             reiniciarJTable(TablaRedes);
            LblTipoRed.setText("Red Clase : B");
            LblMascara.setText("MASCARA DE RED: 255.255.0.0");
            LblPrefijo.setText("PREFIJO INIICAL:  /16");
            System.out.println("Clase B");
            calcularRedesClaseBDinamico(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
             mostrarSubneteo();
        }else if (ValidaRed<224) {//Clase C
              reiniciarVariables();
             reiniciarJTable(TablaRedes);
          LblTipoRed.setText("Red Clase : C");
          LblMascara.setText("MASCARA DE RED: 255.255.255.0");
          LblPrefijo.setText("PREFIJO INIICAL:  /24");
         calcularRedesClaseCDinamico(TxtRedes, TxtHost, TxtOctetoUno, TxtOctetoDos, TxtOctetoTres, TxtOctetoCuatro);
         mostrarSubneteo();
        }else{ //Fuera de rango
            JOptionPane.showMessageDialog(null, "FUERA DE RANGO","RED NO SE PUEDE SUBNETEAR",JOptionPane.WARNING_MESSAGE);
        }
     
        
    }//GEN-LAST:event_BtnDinamicoActionPerformed

    
        private void mostrarSubneteo() {
      String matris [][] = new String [Lista.size()][8];
       
        for (int i = 0; i < Lista.size(); i++) {
            
            matris[i][0] = Lista.get(i).getNumDeRedes();
            matris[i][1] = Lista.get(i).getDireccionIP();
            matris[i][2] = Lista.get(i).getHost();
            matris[i][3] = Lista.get(i).getRedes();
            matris[i][4] = Lista.get(i).getBroadCast();
            matris[i][5] = Lista.get(i).getMascaraDeRed();
            matris[i][6] = Lista.get(i).getPrefijoMascara();
            matris[i][7] = Lista.get(i).getHosXRed();
           
        }
        
        
        
       TablaRedes.setModel(new javax.swing.table.DefaultTableModel(
            matris,
            new String [] {
                "#Red", "Subred", "Primera IP", "Ultima IP", "Broadcast", "MascaraRed", " /...", "Host x Red"
            }
        ));
    }
    
    private void BtnResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BtnResetActionPerformed
        // TODO add your handling code here:
         //Mensaje para preguntar si quiere borrar la tabla
       int resp = JOptionPane.showConfirmDialog(null, "多Esta seguro de eliminar el subneteo actual?", "Alerta!", JOptionPane.YES_NO_OPTION);
        
        if (resp==0) {
            reiniciarJTable(TablaRedes);
           LblHostDisponibles.setText("");
           LblMascara.setText("");
           LblPrefijo.setText("");
           LblTipoRed.setText("");
            
           TxtHost.setText("0");
           TxtOctetoCuatro.setText("0");
           TxtOctetoDos.setText("0");   
           TxtOctetoTres.setText("0");
           TxtOctetoUno.setText("0");
           TxtRedes.setText("0");
           Lista.removeAll(Lista);
        }
        //Funcion que borra la tabla para agregar una nueva
        
//Fin de limpiar las filas
      
        
     
      
    
    }//GEN-LAST:event_BtnResetActionPerformed

    private void TxtOctetoUnoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TxtOctetoUnoActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_TxtOctetoUnoActionPerformed

    private void LblSalirMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_LblSalirMouseEntered
        // TODO add your handling code here:
        LblSalir.setCursor(new Cursor(Cursor.HAND_CURSOR));
         LblInformacion.setCursor(new Cursor(Cursor.HAND_CURSOR));
         BtnDinamico.setCursor(new Cursor(Cursor.HAND_CURSOR));
         BtnEstatico.setCursor(new Cursor(Cursor.HAND_CURSOR));
         BtnReset.setCursor(new Cursor(Cursor.HAND_CURSOR));
    }//GEN-LAST:event_LblSalirMouseEntered

    private void LblSalirMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_LblSalirMouseClicked
        // TODO add your handling code here:
        int resp = JOptionPane.showConfirmDialog(null, "多Esta seguro que deseas salir?", "Alerta!", JOptionPane.YES_NO_OPTION);
        
        if (resp==0) {
            System.exit(0);
        }
    }//GEN-LAST:event_LblSalirMouseClicked

    private void LblInformacionMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_LblInformacionMouseClicked
        // TODO add your handling code here:
        Informacion inf = new Informacion();
    }//GEN-LAST:event_LblInformacionMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Vista.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Vista().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton BtnDinamico;
    private javax.swing.JButton BtnEstatico;
    private javax.swing.JButton BtnReset;
    private javax.swing.JLabel LblHostDisponibles;
    private javax.swing.JLabel LblInformacion;
    private javax.swing.JLabel LblMascara;
    private javax.swing.JLabel LblPrefijo;
    private javax.swing.JLabel LblSalir;
    private javax.swing.JLabel LblTipoRed;
    private javax.swing.JTable TablaRedes;
    private javax.swing.JTextField TxtHost;
    private javax.swing.JTextField TxtOctetoCuatro;
    private javax.swing.JTextField TxtOctetoDos;
    private javax.swing.JTextField TxtOctetoTres;
    private javax.swing.JTextField TxtOctetoUno;
    private javax.swing.JTextField TxtRedes;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables

    private void iniConfiguraciones() {
     
        this.setSize(986, 575);
         this.setLocationRelativeTo(this);
        this.setVisible(true);
        this.setTitle("Calculadora Subneteo Diana Lizbeth & Luis Alan");
        this.setResizable(false);
        this.setIconImage(Calcu.getImage());
        
        
       
    }


    
    //Calcula las redes clase C
    public void calcularRedesClaseC(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
          
        
        //Modifica el Octeto 4 a 0 para generar ip
        if (Ocuatro.getText()!="0") {
           
            Ocuatro.setText("0");
        }
 
        
   
      if (Ocuatro.getText().isEmpty() || Otres.getText().isEmpty() || Odos.getText().isEmpty() || Ouno.getText().isEmpty() || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
      int nHost = Integer.parseInt(redes.getText());
      int nRedes  =Integer.parseInt(host.getText());
        
        
        
        System.out.println("nHost"+nHost);
        System.out.println("nRedes"+nRedes);
        
        
        nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
        
        
        suma = nHost*nRedes;
        
           if (suma>0 && suma<255) {
               
               //Imprime la mascara de red tipo c 
                   for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      sumados = sumados+cond3;
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                     System.out.println("suma"+sumados);
                }
            
            }
         
        }
           
           
        System.out.println("Mascara de red Subneteada 255.255.255."+(sumados-256)+" /"+(diagonalredC-1));
        MascaraRed = "255.255.255."+(sumados-256)+"";
      
        
          //total de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //Muestra en Lbl el numero de host disponibles por red
        LblHostDisponibles.setText("Host disponibles por Red: "+(cond2-2)+"");
        System.out.println("Total de redes "+256/cond2);
        TotalDeRedes = 256/cond2;
        
        HXR = (cond2-2)+"";
        
        
        String RedesChingonas = Ouno.getText()+
                                            "."+Odos.getText()+
                                            "."+Otres.getText()+
                                           ".";
        
        System.out.println(RedesChingonas);
        
        for (int i = 0; i < 256/cond2; i++) {
            RedNum =(i+1);
             numDeRedSt = RedNum+"";
           System.out.print("192.168.1."+x+"           ");
            red = RedesChingonas+x+"";
           System.out.print("192.168.1."+(x+1)+"    ");
           primeraip = RedesChingonas+(x+1)+"    ";
            x=x+cond2;
            System.out.print("192.168.1."+(x-2)+"    ");
            ultimaip =RedesChingonas+(x-2)+"    ";
            System.out.print("192.168.1."+(x-1)+" ");
            Broadcast = RedesChingonas+(x-1)+" ";
            
            System.out.println("");
             PrefijoDeRed ="       /"+(diagonalredC-1)+"";
           Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
             
          
         
        }
        
           }else{
               JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE C MAXIMO: 255 - TUS HOST: "+suma,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
           }
        
        
        
     
        }//Final de if para validar campos vacios 
    }//Fin de la clase C METODO DE SUBNETEO
    
    
    
    
    
    //Calcula las redes Clase B
    public void calcularRedesClaseB(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
     
       
        int diagonalredB = 16;
        
         //Modifica el Octeto 4 a 0 para generar ip
        if (Ocuatro.getText()!="0" || Otres.getText()!="0") {
           
            Ocuatro.setText("0");
            Otres.setText("0");
        }
 
        
   
      if (Ocuatro.getText().isEmpty() || Otres.getText().isEmpty() || Odos.getText().isEmpty() || Ouno.getText().isEmpty() || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
            
        
        int nHost = Integer.parseInt(redes.getText());
        int nRedes = Integer.parseInt(host.getText());
        
           System.out.println(" "+nRedes);
        nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
        suma = nHost*nRedes;
        
        if  (suma>65536){
               JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE B MINIMO 1 - MAXIMO -65536 TUS HOST: "+suma,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
               }else if (nHost<256 && nHost>0) {
               
                     //Imprime la mascara de red tipo c 
                   for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      sumados = sumados+cond3;
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                     System.out.println("suma"+sumados);
                }
            
            }
         
        }
           
           
        System.out.println("Mascara de red Subneteada 255.255.255."+(sumados-256)+" /"+(diagonalredC-1));
        MascaraRed = "255.255.255."+(sumados-256)+"";
      
               
               
             //Sacar e単 mi,erp de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2); // Me da el numero de red a subnetear
                  //    cond4=ArrayClasesRed[i-1][j]; se apaga ya que esta no se usa en este espacio estatico
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        
        HXR = (cond2-2)+"";
        //Imprimir redes en tabla
        
         String primeraparte = Ouno.getText()+
                                            "."+Odos.getText()+
                                            ".";
        
         
               for (int i = 0; i < 256; i++) {
                   
                  int  j=0; //Regresa el valor de J a 0
                  
                   for (j = 0; j < 256; j++) {
                       
                       
                  //Llena la tabla con los datos     
           RedNum++;
          
           red = primeraparte+i+"."+j;  //Subred
           primeraip = primeraparte+i+"."+(j+1);  //Primera ip usable
           
            j=j+cond2;  //Se aumenta el valor del numero d eHost
                       System.out.println("J VALOR "+j);
            ultimaip =primeraparte+i+"."+(j-2);  //Ultima IP usable
            Broadcast = primeraparte+i+"."+(j-1); //Broadcast
            
            System.out.println("");
             numDeRedSt = RedNum+"";
            j=j-1; //Resta el valor de J 2 para que la tabla se imprima correctamente
             
             
       //Llena la tabla 
            PrefijoDeRed ="       /"+(diagonalredC-1)+"";
           Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR); 
                       
                   }
         
               }
        
      
     
           }else      if (suma> 512 && suma<65536) {
         
          //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.0  /"+diagonalredC);
        
        
        
         for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-1][j];
                      sumados = sumados+cond3;
                      diagonalredB++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
            }
         
        }
           
        MascaraRed = "255.255."+(sumados-256)+".0";
        PrefijoDeRed ="       /"+(diagonalredB-1)+"";
        
        
      //total de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                      cond4=ArrayClasesRed[i-1][j];
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
         LblHostDisponibles.setText("Host disponibles por Red: "+(cond2-2)+"");
         
         HXR = (cond2-2)+"";
         
        System.out.println("Total de redes "+256/cond2);
   
        String primeraparte = Ouno.getText()+
                                            "."+Odos.getText()+
                                            ".";
        
        System.out.println(primeraparte);
        
        for (int i = 0; i < 256/cond4; i++) {
            RedNum =(i+1);
           System.out.print("192.168.1."+x+"           ");
           red = primeraparte+x+".0";
           System.out.print("192.168.1."+(x+1)+"    ");
           primeraip = primeraparte+x+".1";
            x=x+cond4;
            System.out.print("192.168.1."+(x-2)+"");
            ultimaip =primeraparte+(x-1)+".254";
            System.out.print("192.168.1."+(x-1)+"");
            Broadcast = primeraparte+(x-1)+".255 ";
            
            System.out.println("");
             numDeRedSt = RedNum+"";
           Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
             
          
         
        }
       }
               
       }
}//fin de clase b
    
    //Calcula las redes clase A
     public void calcularRedesClaseA(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
     
        
        
       int diagonalredA = 8;
        
        
          //Modifica el Octeto 4 a 0 para generar ip
        if (Ocuatro.getText()!="0" || Otres.getText()!="0" || Odos.getText()!="0" ) {
           
            Ocuatro.setText("0");
            Otres.setText("0");
            Odos.setText("0");
          
        }
 
        

   
      if (  Ouno.getText().isEmpty()  || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
        int nHost = Integer.parseInt(redes.getText());
        int nRedes = Integer.parseInt(host.getText());
        
        
        
         System.out.println("Multiplicacion"+suma);
        
         nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
         
        suma = nHost*nRedes;
        
           System.out.println("Suma"+suma);
     
            if (suma>16777216){
                JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE A MINIMO 0 - MAXIMO - 16777216 TUS HOST: "+suma,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
     
           }else   if (nHost<256 && nHost>0) {
               
                     //Imprime la mascara de red tipo c 
                   for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      sumados = sumados+cond3;
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                     System.out.println("suma"+sumados);
                }
            
            }
         
        }
           
           
        System.out.println("Mascara de red Subneteada 255.255.255."+(sumados-256)+" /"+(diagonalredC-1));
        MascaraRed = "255.255.255."+(sumados-256)+"";
      
               
               
             //Sacar el numero  de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2); // Me da el numero de red a subnetear
                  //    cond4=ArrayClasesRed[i-1][j]; se apaga ya que esta no se usa en este espacio estatico
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        
        HXR = (cond2-2)+"";
        //Imprimir redes en tabla
        
         String primeraparte = Ouno.getText()+
                                            ".";
        
             for (int a = 0; a < 256; a++) {
                 int i=0;
                 for ( i = 0; i < 256; i++) {
                  int  j=0; //Regresa el valor de J a 0
                   for (j = 0; j < 256; j++) {
                       
                       
                  //Llena la tabla con los datos     
           RedNum++;
          
           red = primeraparte+a+"."+i+"."+j;  //Subred
           primeraip = primeraparte+a+"."+i+"."+(j+1);  //Primera ip usable
           
            j=j+cond2;  //Se aumenta el valor del numero d eHost
                       System.out.println("J VALOR "+j);
            ultimaip =primeraparte+a+"."+i+"."+(j-2);  //Ultima IP usable
            Broadcast = primeraparte+a+"."+i+"."+(j-1); //Broadcast
            
            System.out.println("");
             numDeRedSt = RedNum+"";
            j=j-1; //Resta el valor de J 2 para que la tabla se imprima correctamente
             
             
       //Llena la tabla 
            PrefijoDeRed ="       /"+(diagonalredC-1)+"";
           Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR); 
                       
                   }
         
               }
                 
                 
             }
         
        
         }else if (nHost>512 && nHost<=65536) {
               
                     //Imprime la mascara de red tipo c 
                   for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-1][j];
                      sumados = sumados+cond3;
                      diagonalredB++;
                  //    System.out.println("j"+(j+1));
                     System.out.println("suma"+sumados);
                }
            
            }
         
        }
           
           
        System.out.println("Mascara de red Subneteada 255.255.255."+(sumados-256)+" /"+(diagonalredC-1));
        MascaraRed = "255.255."+(sumados-256)+".0";
      
               int t=0;
               
             //Sacar e単 mi,erp de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-1][j];
                      t=ArrayClasesRed[i][j];
                      System.out.println("Clase A condicion 2"+cond2); // Me da el numero de red a subnetear
                  //    cond4=ArrayClasesRed[i-1][j]; se apaga ya que esta no se usa en este espacio estatico
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        
        HXR = (t-2)+"";
        //Imprimir redes en tabla
        
         String primeraparte = Ouno.getText()+
                                            ".";
        
         
               for (int i = 0; i < 256; i++) {
                   
                  int  j=0; //Regresa el valor de J a 0
                  
                   for (j = 0; j < 256; j++) {
                       
                       
                  //Llena la tabla con los datos     
           RedNum++;
          
           red = primeraparte+i+"."+j+".0";  //Subred
           primeraip = primeraparte+i+"."+j+".1";  //Primera ip usable
           
            j=j+cond2;  //Se aumenta el valor del numero d eHost
                       System.out.println("J VALOR "+j);
            ultimaip =primeraparte+i+"."+(j-1)+".254";  //Ultima IP usable
            Broadcast = primeraparte+i+"."+(j-1)+".255"; //Broadcast
            
            System.out.println("");
             numDeRedSt = RedNum+"";
            j=j-1; //Resta el valor de J 2 para que la tabla se imprima correctamente
             
             
       //Llena la tabla 
            PrefijoDeRed ="       /"+(diagonalredB-1)+"";
           Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR); 
                       
                   }
         
               }
        
      
     
           }else  if (suma> 131072 && suma<16777216) {
        
         
          //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.0  /"+diagonalredC);
        
        
        
         for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-2][j];
                      sumados = sumados+cond3;
                      diagonalredA++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
            }
         
        }
           
        MascaraRed = "255."+(sumados-256)+".0.0";
        PrefijoDeRed ="       /"+(diagonalredA-1)+"";
        
        
      //total de redes
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                      cond4=ArrayClasesRed[i-2][j];
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            }
            System.out.println("");
        }
        
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        HXR = (cond2-2)+"";
        
         LblHostDisponibles.setText("Host disponibles por Red: "+(cond2-2)+"");
        System.out.println("Total de redes "+256/cond2);
   
        String primeraparte = Ouno.getText()+
                                            ".";
        
        System.out.println(primeraparte);
        
        for (int i = 0; i < 256/cond4; i++) {
           RedNum =(i+1);
           System.out.print("192.168.1."+x+"           ");
           red = primeraparte+x+".0.0";
           System.out.print("192.168.1."+(x+1)+"    ");
           primeraip = primeraparte+x+".0.1";
            x=x+cond4;
            System.out.print("192.168.1."+(x-2)+"");
            ultimaip =primeraparte+(x-1)+".255.254";
            System.out.print("192.168.1."+(x-1)+"");
            Broadcast = primeraparte+(x-1)+".255.255 ";
            
            System.out.println("");
            
            
            //Llena la tabla
             numDeRedSt = RedNum+"";
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
             
          
         
        }
       }
           
          
           
       }
}//Fin de clase A
     
     //Calcula las redes clase C
    public void calcularRedesClaseCDinamico(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
     
          //Modifica el Octeto 4 a 0 para generar ip
       if (Ocuatro.getText()!="0") {
           
            Ocuatro.setText("0");
        }
 
        
   
      if (Ocuatro.getText().isEmpty() || Otres.getText().isEmpty() || Odos.getText().isEmpty() || Ouno.getText().isEmpty() || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
        int nHost = Integer.parseInt(redes.getText());
        int nRedes = Integer.parseInt(host.getText());
        
        
        
        suma = nHost*nRedes;
        sumados = nHost*nRedes;
        
        
      //  nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
        
     
            
        
         int PedidoUsuario[] = new int[nRedes];
         
         for (int i = 0; i < PedidoUsuario.length; i++) {
         System.out.println("Cuantos host necesitas en tu red: "+i );
         int numero =Integer.parseInt(JOptionPane.showInputDialog("Cuantos Host necesitas en tu RED # " +(i+1)+""));
       // nHost = Tc.nextInt(); CREAR UN ALERT QUE PIDA NUMEROS PARA AGREGARLOS
         PedidoUsuario[i]=numero;
        }
         
             //Metodo Burbuja
           /* Bucle desde 0 hasta la longitud del array -1 */
        for (int i = 0; i < PedidoUsuario.length - 1; i++) {
            /* Bucle anidado desde 0 hasta la longitud del array -1 */
            for (int j = 0; j < PedidoUsuario.length - 1; j++) { /* Si el n炭mero almacenado en la posici坦n j es mayor que el de la posici坦n j+1 (el siguiente del array) */ if (PedidoUsuario[j] > PedidoUsuario[j + 1]) {
                    /* guardamos el n炭mero de la posicion j+1 en una variable (el menor) */
                    int temp = PedidoUsuario[j + 1];
                    /* Lo intercambiamos de posici坦n */
                    PedidoUsuario[j + 1] = PedidoUsuario[j];
                    PedidoUsuario[j] = temp;
                    /* y volvemos al inicio para comparar los siguientes hasta que todos se hayan comparado*/
                    /* de esta forma vamos dejando los n炭meros mayores al final del array en orden*/
                }
            }
        }
         
           if (sumados>=0 && sumados<=255) {
        System.out.println("x "+PedidoUsuario.length);
        
        
        
        //Este for sacara los datos del arreglo de mayor a menor para ir generando las redes
         for (int y = PedidoUsuario.length; y >0; y--) {
             System.out.println();
             
             ContadorDenumeros++;
             
             nHost =PedidoUsuario[y-1];
             NumHostRed = PedidoUsuario[y-1];
       //Esta es la condicion del limite de clase
        totalHost = nHost*numRedes;
        
             
             
             
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                }
                
                if (totalHost<arregloRed && cond==0) {
                    cond=ArrayClasesRed[i][j];
                     System.out.println(cond);
                }
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
            if (x>255) {
                System.out.println("Ya no puedes crear mas redes");
                JOptionPane.showMessageDialog(null, "SOLO TENIAS ESPACIO PARA "+ContadorParaIf+" REDES",
                "ESPACIO INSUFICIENTE", JOptionPane.ERROR_MESSAGE);
                
            //    JOptionPane.showConfirmDialog(null, "SOLO TENIAS ESPACIO PARA "+ContadorParaIf+" REDES");
            }else{
                
                  HXR = (cond2-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            "."+Odos.getText()+
                                            "."+Otres.getText()+
                                           ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
            System.out.print("192.168.1."+x+"           ");
            red = RedesChingonas+x+" ";
            
            System.out.print("192.168.1."+(x+1+"    "));
             primeraip = RedesChingonas+(x+1)+"    ";
             
            x=x+cond2;
            
             System.out.print("192.168.1."+(x-2)+"    ");
               ultimaip =RedesChingonas+(x-2)+"    ";
               
             System.out.print("192.168.1."+(x-1)+" ");
             Broadcast = RedesChingonas+(x-1)+" ";
             
             System.out.println("");
             
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      suma = suma+cond3;
                 
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255.255"+(suma-256)+"";
          PrefijoDeRed = (diagonalredC-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredC =24;
           
        }
        
        }
         
         }
        }
        else
        {
             JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE C MAXIMO: 255 - TUS HOST: "+sumados,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
  
        }//Fin de el rango de redes if   
       }//Fin de condiciones de campos
    }//Fin de la clase C METODO DE SUBNETEO dimamico
    
    
    
     public void calcularRedesClaseBDinamico(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
      
   int total =0;         
//Modifica el Octeto 4 a 0 para generar ip
       if (Ocuatro.getText()!="0") {
           
            Ocuatro.setText("0");
        }
 
        
   
      if (Ocuatro.getText().isEmpty() || Otres.getText().isEmpty() || Odos.getText().isEmpty() || Ouno.getText().isEmpty() || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
        int nHost = Integer.parseInt(redes.getText());
        int nRedes = Integer.parseInt(host.getText());
        
        
        
        suma = nHost*nRedes;
        sumados = nHost*nRedes;
       int rara=0;
        
      //  nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
        
     
            
        
         int PedidoUsuario[] = new int[nRedes];
         
         for (int i = 0; i < PedidoUsuario.length; i++) {
         System.out.println("Cuantos host necesitas en tu red: "+i );
         int numero =Integer.parseInt(JOptionPane.showInputDialog("Cuantos Host necesitas en tu RED # " +(i+1)+""));
       // nHost = Tc.nextInt(); CREAR UN ALERT QUE PIDA NUMEROS PARA AGREGARLOS
         PedidoUsuario[i]=numero;
         rara=rara+numero;
         
        }
         
           if (rara>65536) {
               JOptionPane.showMessageDialog(null, "Noo chavo los equipos son demasiados para esta red intenta con un nunmero menor de host, tus host: "+rara+" Numero maximo 65536 de host");
           }else{
         
             //Metodo Burbuja
           /* Bucle desde 0 hasta la longitud del array -1 */
        for (int i = 0; i < PedidoUsuario.length - 1; i++) {
            /* Bucle anidado desde 0 hasta la longitud del array -1 */
            for (int j = 0; j < PedidoUsuario.length - 1; j++) { /* Si el n炭mero almacenado en la posici坦n j es mayor que el de la posici坦n j+1 (el siguiente del array) */ if (PedidoUsuario[j] > PedidoUsuario[j + 1]) {
                    /* guardamos el n炭mero de la posicion j+1 en una variable (el menor) */
                    int temp = PedidoUsuario[j + 1];
                    /* Lo intercambiamos de posici坦n */
                    PedidoUsuario[j + 1] = PedidoUsuario[j];
                    PedidoUsuario[j] = temp;
                    /* y volvemos al inicio para comparar los siguientes hasta que todos se hayan comparado*/
                    /* de esta forma vamos dejando los n炭meros mayores al final del array en orden*/
                }
            }
        }
         
        
        
         
        
        
        
        //Este for sacara los datos del arreglo de mayor a menor para ir generando las redes
         for (int y = PedidoUsuario.length; y >0; y--) {
             System.out.println();
             
             ContadorDenumeros++;
             
             nHost =PedidoUsuario[y-1];
             NumHostRed = PedidoUsuario[y-1];
       //Esta es la condicion del limite de clase
        totalHost = nHost*numRedes;
        
         
             
             if (totalHost>65536) {
                 
                JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE B MINIMO 0 - MAXIMO - 65536 TUS HOST: "+total,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
           
             }else if(PedidoUsuario[y-1]>0 && PedidoUsuario[y-1]<=256){
                 cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                      
                }
                
            
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
    
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
     
                
                  HXR = (cond2-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            "."+Odos.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
         
            red = RedesChingonas+b+"."+c+" ";
            
 
             primeraip = RedesChingonas+b+"."+(c+1)+"    ";
             
            c=c+cond2;
            

               ultimaip =RedesChingonas+b+"."+(c-1)+" ";
               

             Broadcast = RedesChingonas+b+"."+(c-1)+"";
             
             if (c>255) {
                c=0; b++;
            }
             
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      suma = suma+cond3;
                 
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255.255."+(suma-256)+"";
          PrefijoDeRed = (diagonalredC-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredC =24;
           
        
        
        }
         
         }else if(PedidoUsuario[y-1]<512) {
             cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-1][j];
                      System.out.println(cond2);
                    cond=ArrayClasesRed[i][j];
                }
                
          
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
       
                
                  HXR = (cond-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            "."+Odos.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
       
            red = RedesChingonas+b+".0 ";
            
     
             primeraip = RedesChingonas+b+".1";
             
            b=b+cond2;
            
       
               ultimaip =RedesChingonas+(b-1)+".254    ";
               
   
             Broadcast = RedesChingonas+(b-1)+".255 ";
             
             System.out.println("");
          
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 i++;
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-1][j];
                      suma = suma+cond3;
                 
                      diagonalredB++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        i--;
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255."+(suma-256)+".0";
          PrefijoDeRed = (diagonalredB-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredC =24; diagonalredB=16;
           
    
        
        }
         
         }else if(PedidoUsuario[y-1]>512 && PedidoUsuario[y-1]<65536){
             cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-1][j];
                      System.out.println(cond2);
                    cond=ArrayClasesRed[i][j];
                }
                
          
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
       
                
                  HXR = (cond-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            "."+Odos.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
       
            red = RedesChingonas+b+".0 ";
            
     
             primeraip = RedesChingonas+b+".1";
             
            b=b+cond2;
            
       
               ultimaip =RedesChingonas+(b-1)+".254    ";
               
   
             Broadcast = RedesChingonas+(b-1)+".255 ";
             
             System.out.println("");
          
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 i++;
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-1][j];
                      suma = suma+cond3;
                 
                      diagonalredB++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        i--;
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255."+(suma-256)+".0";
          PrefijoDeRed = (diagonalredB-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredB=16;
           
    
        
        }
         
         }
         }
       
       }//Fin de condiciones de campos
       }
    }//Fin de la clase B METODO DE SUBNETEO DINAMICO
    
    
     public void calcularRedesClaseADinamico(JTextField redes, JTextField host,JTextField Ouno, JTextField Odos, JTextField Otres, JTextField Ocuatro){
     
   int total =0;         
//Modifica el Octeto 4 a 0 para generar ip
       if (Ocuatro.getText()!="0") {
           
            Ocuatro.setText("0");
        }
 
        
   
      if (Ocuatro.getText().isEmpty() || Otres.getText().isEmpty() || Odos.getText().isEmpty() || Ouno.getText().isEmpty() || redes.getText().isEmpty() || host.getText().isEmpty()) {
            //Mensaje despues de validar condiciones cumplidas
            JOptionPane.showMessageDialog(null, "LOS CAMPOS NO PUEDEN ESTAR VACIOS","CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
          
        }
        else 
       {
            
        int nHost = Integer.parseInt(redes.getText());
        int nRedes = Integer.parseInt(host.getText());
        
        
        
        suma = nHost*nRedes;
        sumados = nHost*nRedes;
       int rara=0;
        
      //  nHost = Integer.parseInt(JOptionPane.showInputDialog("Ingresa el numero de Host por red"));
        
     
            
        
         int PedidoUsuario[] = new int[nRedes];
         
         for (int i = 0; i < PedidoUsuario.length; i++) {
         System.out.println("Cuantos host necesitas en tu red: "+i );
         int numero =Integer.parseInt(JOptionPane.showInputDialog("Cuantos Host necesitas en tu RED # " +(i+1)+""));
       // nHost = Tc.nextInt(); CREAR UN ALERT QUE PIDA NUMEROS PARA AGREGARLOS
         PedidoUsuario[i]=numero;
         rara=rara+numero;
         
        }
         
           if (rara>16777216) {
               JOptionPane.showMessageDialog(null, "Noo chavo los equipos son demasiados para esta red intenta con un nunmero menor de host, tus host: "+rara+" Numero maximo 65536 de host");
           }else{
         
             //Metodo Burbuja
           /* Bucle desde 0 hasta la longitud del array -1 */
        for (int i = 0; i < PedidoUsuario.length - 1; i++) {
            /* Bucle anidado desde 0 hasta la longitud del array -1 */
            for (int j = 0; j < PedidoUsuario.length - 1; j++) { /* Si el n炭mero almacenado en la posici坦n j es mayor que el de la posici坦n j+1 (el siguiente del array) */ if (PedidoUsuario[j] > PedidoUsuario[j + 1]) {
                    /* guardamos el n炭mero de la posicion j+1 en una variable (el menor) */
                    int temp = PedidoUsuario[j + 1];
                    /* Lo intercambiamos de posici坦n */
                    PedidoUsuario[j + 1] = PedidoUsuario[j];
                    PedidoUsuario[j] = temp;
                    /* y volvemos al inicio para comparar los siguientes hasta que todos se hayan comparado*/
                    /* de esta forma vamos dejando los n炭meros mayores al final del array en orden*/
                }
            }
        }
         
        
        
         
        
        
        
        //Este for sacara los datos del arreglo de mayor a menor para ir generando las redes
         for (int y = PedidoUsuario.length; y >0; y--) {
             System.out.println();
             
             ContadorDenumeros++;
             
             nHost =PedidoUsuario[y-1];
             NumHostRed = PedidoUsuario[y-1];
             System.out.println("Pedidos"+PedidoUsuario[y-1]);
       //Esta es la condicion del limite de clase
        totalHost = nHost*numRedes;
        
        
             
             if (totalHost>16777216) {
                 
                JOptionPane.showMessageDialog(null, "EL NUMERO DE HOST ES DEMASIADO GRANDE PARA LA CLASE B MINIMO 0 - MAXIMO - 65536 TUS HOST: "+total,"CAMPOS VACIOS",JOptionPane.WARNING_MESSAGE);
           
             }else if(PedidoUsuario[y-1]>0 && PedidoUsuario[y-1]<=256){
                 cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i][j];
                      System.out.println(cond2);
                      
                }
                
            
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
    
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
     
                
                  HXR = (cond2-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
         
            red = RedesChingonas+a+"."+b+"."+c+" ";
            
 
             primeraip = RedesChingonas+a+"."+b+"."+(c+1)+"    ";
             
            c=c+cond2;
            

               ultimaip =RedesChingonas+a+"."+b+"."+(c-1)+" ";
               

             Broadcast = RedesChingonas+a+"."+b+"."+(c-1)+"";
             
             if (c>255) {
                c=0; b++;
            }
             
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i][j];
                      suma = suma+cond3;
                 
                      diagonalredC++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255.255."+(suma-256)+"";
          PrefijoDeRed = (diagonalredC-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredC =24;
           
        
        
        }
         
         }else if(PedidoUsuario[y-1]>512 && PedidoUsuario[y-1]<65536){
             cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                
                if (nHost<=arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-1][j];
                      System.out.println(cond2);
                    cond=ArrayClasesRed[i][j];
                }
                
          
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
       
                
                  HXR = (cond-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
       
            red = RedesChingonas+a+"."+b+".0 ";
            
     
             primeraip = RedesChingonas+a+"."+b+".1";
             
            b=b+cond2;
            
       
               ultimaip =RedesChingonas+a+"."+(b-1)+".254    ";
               
   
             Broadcast = RedesChingonas+a+"."+(b-1)+".255 ";
             
             System.out.println("");
          
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0;
             
             if (b<255) {
               a++;
            }
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 i++;
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-1][j];
                      suma = suma+cond3;
                 
                      diagonalredB++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        i--;
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255.255."+(suma-256)+".0";
          PrefijoDeRed = (diagonalredB-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredB =16;
           
    
        
        }
         
         }else if(PedidoUsuario[y-1]<131072 ){
             cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                System.out.println("ARREGLO "+arregloRed);
                if (nHost<arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-2][j];
                      System.out.println(cond2);
                    cond=ArrayClasesRed[i][j];
                }
                
          
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
       
                
                  HXR = (cond-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
       
            red = RedesChingonas+a+".0.0 ";
            
     
             primeraip = RedesChingonas+a+".0.1";
             
            a=a+cond2;
            
       
               ultimaip =RedesChingonas+(a-1)+".255.254    ";
               
   
             Broadcast = RedesChingonas+(a-1)+".255.255 ";
             
             System.out.println("");
          
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0; cond3=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 i=i+2;
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-2][j];
                      suma = suma+cond3;
                 
                      diagonalredA++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        i=i-2;
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255."+(suma-256)+".0.0";
          PrefijoDeRed = (diagonalredA-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredA =8;
           
    
        
        }
         
         
         }else if(PedidoUsuario[y-1]>131072 && PedidoUsuario[y-1]<16777216){
             cond2=0;
             //total de redes los mide con el arreglo de host
        for (int i = 0; i < ArrayClasesRed.length; i++) {
            
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
                
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                System.out.println("ARREGLO "+arregloRed);
                if (nHost<arregloRed && cond2==0) {
                      cond2=ArrayClasesRed[i-2][j];
                      System.out.println(cond2);
                    cond=ArrayClasesRed[i][j];
                }
                
          
            
            }
            System.out.println("");
        }
        
        //en esta parte se puede implementar un if para separar los tipos de clases a b c
        System.out.println("Cond "+cond);
        System.out.println("Cond "+cond2);
        
        //agregar los numeros de la red a la cadena suma de redes
         
        
        System.out.println("Total de redes "+256/cond2);
   
        System.out.println("Red 192.168.1.0");
       
        for (int i = 0; i < 1; i++) {
            
       
                
                  HXR = (cond-2)+"";
                
                 String RedesChingonas = Ouno.getText()+
                                            ".";
                
                ContadorParaIf++;
            System.out.print("#Red: "+ContadorDenumeros+"           ");
            RedNum =ContadorDenumeros;
            
       
            red = RedesChingonas+a+".0.0 ";
            
     
             primeraip = RedesChingonas+a+".0.1";
             
            a=a+cond2;
            
       
               ultimaip =RedesChingonas+(a-1)+".255.254    ";
               
   
             Broadcast = RedesChingonas+(a-1)+".255.255 ";
             
             System.out.println("");
          
             //Se inician las redes en 0
             totalHost =0; nHost =0; cond=0; cond2=0; cond3=0;
             
                    //Mascara de red
        System.out.println("Mascara de red Brindada 255.255.255.  "+(suma-256)+" /"+diagonalredC);
                 
                 i=i+2;
            for (int j = 0; j < ArrayClasesRed[i].length; j++) {
             //   System.out.println("Fila: "+(i+1)+" Columna : "+(j+1)+" "+ArrayClasesRed[i][j]);
                arregloRed =ArrayClasesRed[i][j];
                if (NumHostRed<arregloRed && cond3<256) {
                      cond3=ArrayClasesRed[i-2][j];
                      suma = suma+cond3;
                 
                      diagonalredA++;
                  //    System.out.println("j"+(j+1));
                    //  System.out.println("suma"+suma);
                }
            
           
   
        }//Fin de for que imprime la amscara de red
        i=i-2;
          System.out.println("Mascara de red Subneteada 255.255.255."+(suma-256)+" /"+(diagonalredC-1));
          
          MascaraRed = "255."+(suma-256)+".0.0";
          PrefijoDeRed = (diagonalredA-1)+"";
           numDeRedSt = RedNum+"";
           
          Llenartabla(red, primeraip, ultimaip,Broadcast,MascaraRed,PrefijoDeRed,numDeRedSt,HXR);
          
           cond3=0; suma =0; diagonalredA =8;
           
    
        
        }
         
         
         }//fin de siclo A
       
       }//Fin de condiciones de campos
       }
       }
    }//Fin de la clase B METODO DE SUBNETEO DINAMICO
    
     
     public void Llenartabla(String numdered,String red, String  primeraip, String ultimaip, String Broad, String MascaraRed, String PrefijoRed, String HostEnCadaRed){
         
      Redes redes = new Redes(numdered,red,primeraip,ultimaip,Broad,MascaraRed,PrefijoRed,HostEnCadaRed);
      Lista.add(redes);
        
      
    }
     
     public static void reiniciarJTable(javax.swing.JTable Tabla){
         
         
         //Crea la tabla default
         DefaultTableModel modelo = (DefaultTableModel) Tabla.getModel();
         
         //Mientras el modelo de la fila no sea 0 borra los datos
        while(modelo.getRowCount()>0)modelo.removeRow(0);
 
         TableColumnModel modCol = Tabla.getColumnModel();
        while(modCol.getColumnCount()>0)modCol.removeColumn(modCol.getColumn(0));
    }
     
     public void reiniciarVariables(){
         numRedes=0;
        totalHost=0;
        arregloRed=0;cond=0;cond2=0;x=0;cond3=0;suma=0;diagonalredC=24;sumados=0;cond4=0;RedNum=0;ContadorDenumeros=0;NumHostRed=0;ContadorParaIf=0;
     }
    
}//FINAL